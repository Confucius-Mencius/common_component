// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace test {
class ComplexMessage;
class ComplexMessageDefaultTypeInternal;
extern ComplexMessageDefaultTypeInternal _ComplexMessage_default_instance_;
class ComplexMessage_SubMessage;
class ComplexMessage_SubMessageDefaultTypeInternal;
extern ComplexMessage_SubMessageDefaultTypeInternal _ComplexMessage_SubMessage_default_instance_;
class EchoRequest;
class EchoRequestDefaultTypeInternal;
extern EchoRequestDefaultTypeInternal _EchoRequest_default_instance_;
}  // namespace test

namespace test {

namespace protobuf_test_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_test_2eproto

enum ComplexMessage_SubEnum {
  ComplexMessage_SubEnum_VALUE1 = 10,
  ComplexMessage_SubEnum_VALUE2 = 20
};
bool ComplexMessage_SubEnum_IsValid(int value);
const ComplexMessage_SubEnum ComplexMessage_SubEnum_SubEnum_MIN = ComplexMessage_SubEnum_VALUE1;
const ComplexMessage_SubEnum ComplexMessage_SubEnum_SubEnum_MAX = ComplexMessage_SubEnum_VALUE2;
const int ComplexMessage_SubEnum_SubEnum_ARRAYSIZE = ComplexMessage_SubEnum_SubEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexMessage_SubEnum_descriptor();
inline const ::std::string& ComplexMessage_SubEnum_Name(ComplexMessage_SubEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexMessage_SubEnum_descriptor(), value);
}
inline bool ComplexMessage_SubEnum_Parse(
    const ::std::string& name, ComplexMessage_SubEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexMessage_SubEnum>(
    ComplexMessage_SubEnum_descriptor(), name, value);
}
// ===================================================================

class EchoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:test.EchoRequest) */ {
 public:
  EchoRequest();
  virtual ~EchoRequest();

  EchoRequest(const EchoRequest& from);

  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EchoRequest(EchoRequest&& from) noexcept
    : EchoRequest() {
    *this = ::std::move(from);
  }

  inline EchoRequest& operator=(EchoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoRequest& default_instance();

  static inline const EchoRequest* internal_default_instance() {
    return reinterpret_cast<const EchoRequest*>(
               &_EchoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(EchoRequest* other);
  friend void swap(EchoRequest& a, EchoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EchoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EchoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EchoRequest& from);
  void MergeFrom(const EchoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EchoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:test.EchoRequest)
 private:
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct protobuf_test_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ComplexMessage_SubMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:test.ComplexMessage.SubMessage) */ {
 public:
  ComplexMessage_SubMessage();
  virtual ~ComplexMessage_SubMessage();

  ComplexMessage_SubMessage(const ComplexMessage_SubMessage& from);

  inline ComplexMessage_SubMessage& operator=(const ComplexMessage_SubMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComplexMessage_SubMessage(ComplexMessage_SubMessage&& from) noexcept
    : ComplexMessage_SubMessage() {
    *this = ::std::move(from);
  }

  inline ComplexMessage_SubMessage& operator=(ComplexMessage_SubMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexMessage_SubMessage& default_instance();

  static inline const ComplexMessage_SubMessage* internal_default_instance() {
    return reinterpret_cast<const ComplexMessage_SubMessage*>(
               &_ComplexMessage_SubMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ComplexMessage_SubMessage* other);
  friend void swap(ComplexMessage_SubMessage& a, ComplexMessage_SubMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComplexMessage_SubMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ComplexMessage_SubMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ComplexMessage_SubMessage& from);
  void MergeFrom(const ComplexMessage_SubMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ComplexMessage_SubMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .test.EchoRequest echo = 2;
  int echo_size() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::test::EchoRequest& echo(int index) const;
  ::test::EchoRequest* mutable_echo(int index);
  ::test::EchoRequest* add_echo();
  ::google::protobuf::RepeatedPtrField< ::test::EchoRequest >*
      mutable_echo();
  const ::google::protobuf::RepeatedPtrField< ::test::EchoRequest >&
      echo() const;

  // required string field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:test.ComplexMessage.SubMessage)
 private:
  void set_has_field();
  void clear_has_field();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::test::EchoRequest > echo_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  friend struct protobuf_test_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ComplexMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:test.ComplexMessage) */ {
 public:
  ComplexMessage();
  virtual ~ComplexMessage();

  ComplexMessage(const ComplexMessage& from);

  inline ComplexMessage& operator=(const ComplexMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComplexMessage(ComplexMessage&& from) noexcept
    : ComplexMessage() {
    *this = ::std::move(from);
  }

  inline ComplexMessage& operator=(ComplexMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexMessage& default_instance();

  static inline const ComplexMessage* internal_default_instance() {
    return reinterpret_cast<const ComplexMessage*>(
               &_ComplexMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ComplexMessage* other);
  friend void swap(ComplexMessage& a, ComplexMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComplexMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ComplexMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ComplexMessage& from);
  void MergeFrom(const ComplexMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ComplexMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ComplexMessage_SubMessage SubMessage;

  typedef ComplexMessage_SubEnum SubEnum;
  static const SubEnum VALUE1 =
    ComplexMessage_SubEnum_VALUE1;
  static const SubEnum VALUE2 =
    ComplexMessage_SubEnum_VALUE2;
  static inline bool SubEnum_IsValid(int value) {
    return ComplexMessage_SubEnum_IsValid(value);
  }
  static const SubEnum SubEnum_MIN =
    ComplexMessage_SubEnum_SubEnum_MIN;
  static const SubEnum SubEnum_MAX =
    ComplexMessage_SubEnum_SubEnum_MAX;
  static const int SubEnum_ARRAYSIZE =
    ComplexMessage_SubEnum_SubEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SubEnum_descriptor() {
    return ComplexMessage_SubEnum_descriptor();
  }
  static inline const ::std::string& SubEnum_Name(SubEnum value) {
    return ComplexMessage_SubEnum_Name(value);
  }
  static inline bool SubEnum_Parse(const ::std::string& name,
      SubEnum* value) {
    return ComplexMessage_SubEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated sint64 _int = 3;
  int _int_size() const;
  void clear__int();
  static const int kIntFieldNumber = 3;
  ::google::protobuf::int64 _int(int index) const;
  void set__int(int index, ::google::protobuf::int64 value);
  void add__int(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      _int() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable__int();

  // repeated .test.ComplexMessage.SubEnum _enum = 11;
  int _enum_size() const;
  void clear__enum();
  static const int kEnumFieldNumber = 11;
  ::test::ComplexMessage_SubEnum _enum(int index) const;
  void set__enum(int index, ::test::ComplexMessage_SubEnum value);
  void add__enum(::test::ComplexMessage_SubEnum value);
  const ::google::protobuf::RepeatedField<int>& _enum() const;
  ::google::protobuf::RepeatedField<int>* mutable__enum();

  // repeated string str_list = 12;
  int str_list_size() const;
  void clear_str_list();
  static const int kStrListFieldNumber = 12;
  const ::std::string& str_list(int index) const;
  ::std::string* mutable_str_list(int index);
  void set_str_list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_str_list(int index, ::std::string&& value);
  #endif
  void set_str_list(int index, const char* value);
  void set_str_list(int index, const char* value, size_t size);
  ::std::string* add_str_list();
  void add_str_list(const ::std::string& value);
  #if LANG_CXX11
  void add_str_list(::std::string&& value);
  #endif
  void add_str_list(const char* value);
  void add_str_list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& str_list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_str_list();

  // required string _str = 1;
  bool has__str() const;
  void clear__str();
  static const int kStrFieldNumber = 1;
  const ::std::string& _str() const;
  void set__str(const ::std::string& value);
  #if LANG_CXX11
  void set__str(::std::string&& value);
  #endif
  void set__str(const char* value);
  void set__str(const char* value, size_t size);
  ::std::string* mutable__str();
  ::std::string* release__str();
  void set_allocated__str(::std::string* _str);

  // required bytes _bin = 4;
  bool has__bin() const;
  void clear__bin();
  static const int kBinFieldNumber = 4;
  const ::std::string& _bin() const;
  void set__bin(const ::std::string& value);
  #if LANG_CXX11
  void set__bin(::std::string&& value);
  #endif
  void set__bin(const char* value);
  void set__bin(const void* value, size_t size);
  ::std::string* mutable__bin();
  ::std::string* release__bin();
  void set_allocated__bin(::std::string* _bin);

  // optional .test.ComplexMessage.SubMessage sub = 10;
  bool has_sub() const;
  void clear_sub();
  static const int kSubFieldNumber = 10;
  const ::test::ComplexMessage_SubMessage& sub() const;
  ::test::ComplexMessage_SubMessage* mutable_sub();
  ::test::ComplexMessage_SubMessage* release_sub();
  void set_allocated_sub(::test::ComplexMessage_SubMessage* sub);

  // optional float _float = 2;
  bool has__float() const;
  void clear__float();
  static const int kFloatFieldNumber = 2;
  float _float() const;
  void set__float(float value);

  // required bool _bool = 5;
  bool has__bool() const;
  void clear__bool();
  static const int kBoolFieldNumber = 5;
  bool _bool() const;
  void set__bool(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ComplexMessage)
  // @@protoc_insertion_point(class_scope:test.ComplexMessage)
 private:
  void set_has__str();
  void clear_has__str();
  void set_has__float();
  void clear_has__float();
  void set_has__bin();
  void clear_has__bin();
  void set_has__bool();
  void clear_has__bool();
  void set_has_sub();
  void clear_has_sub();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > _int_;
  ::google::protobuf::RepeatedField<int> _enum_;
  ::google::protobuf::RepeatedPtrField< ::std::string> str_list_;
  ::google::protobuf::internal::ArenaStringPtr _str_;
  ::google::protobuf::internal::ArenaStringPtr _bin_;
  ::test::ComplexMessage_SubMessage* sub_;
  float _float_;
  bool _bool_;
  friend struct protobuf_test_2eproto::TableStruct;
};
// ===================================================================

static const int kEBoolFieldNumber = 101;
extern ::google::protobuf::internal::ExtensionIdentifier< ::test::ComplexMessage,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  e_bool;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EchoRequest

// required string text = 1;
inline bool EchoRequest::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoRequest::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& EchoRequest::text() const {
  // @@protoc_insertion_point(field_get:test.EchoRequest.text)
  return text_.GetNoArena();
}
inline void EchoRequest::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:test.EchoRequest.text)
}
#if LANG_CXX11
inline void EchoRequest::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:test.EchoRequest.text)
}
#endif
inline void EchoRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:test.EchoRequest.text)
}
inline void EchoRequest::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:test.EchoRequest.text)
}
inline ::std::string* EchoRequest::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:test.EchoRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EchoRequest::release_text() {
  // @@protoc_insertion_point(field_release:test.EchoRequest.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EchoRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:test.EchoRequest.text)
}

// -------------------------------------------------------------------

// ComplexMessage_SubMessage

// required string field = 1;
inline bool ComplexMessage_SubMessage::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplexMessage_SubMessage::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplexMessage_SubMessage::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplexMessage_SubMessage::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field();
}
inline const ::std::string& ComplexMessage_SubMessage::field() const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage.SubMessage.field)
  return field_.GetNoArena();
}
inline void ComplexMessage_SubMessage::set_field(const ::std::string& value) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:test.ComplexMessage.SubMessage.field)
}
#if LANG_CXX11
inline void ComplexMessage_SubMessage::set_field(::std::string&& value) {
  set_has_field();
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:test.ComplexMessage.SubMessage.field)
}
#endif
inline void ComplexMessage_SubMessage::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:test.ComplexMessage.SubMessage.field)
}
inline void ComplexMessage_SubMessage::set_field(const char* value, size_t size) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:test.ComplexMessage.SubMessage.field)
}
inline ::std::string* ComplexMessage_SubMessage::mutable_field() {
  set_has_field();
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage.SubMessage.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComplexMessage_SubMessage::release_field() {
  // @@protoc_insertion_point(field_release:test.ComplexMessage.SubMessage.field)
  clear_has_field();
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComplexMessage_SubMessage::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    set_has_field();
  } else {
    clear_has_field();
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:test.ComplexMessage.SubMessage.field)
}

// repeated .test.EchoRequest echo = 2;
inline int ComplexMessage_SubMessage::echo_size() const {
  return echo_.size();
}
inline void ComplexMessage_SubMessage::clear_echo() {
  echo_.Clear();
}
inline const ::test::EchoRequest& ComplexMessage_SubMessage::echo(int index) const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage.SubMessage.echo)
  return echo_.Get(index);
}
inline ::test::EchoRequest* ComplexMessage_SubMessage::mutable_echo(int index) {
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage.SubMessage.echo)
  return echo_.Mutable(index);
}
inline ::test::EchoRequest* ComplexMessage_SubMessage::add_echo() {
  // @@protoc_insertion_point(field_add:test.ComplexMessage.SubMessage.echo)
  return echo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::test::EchoRequest >*
ComplexMessage_SubMessage::mutable_echo() {
  // @@protoc_insertion_point(field_mutable_list:test.ComplexMessage.SubMessage.echo)
  return &echo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::test::EchoRequest >&
ComplexMessage_SubMessage::echo() const {
  // @@protoc_insertion_point(field_list:test.ComplexMessage.SubMessage.echo)
  return echo_;
}

// -------------------------------------------------------------------

// ComplexMessage

// required string _str = 1;
inline bool ComplexMessage::has__str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplexMessage::set_has__str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplexMessage::clear_has__str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplexMessage::clear__str() {
  _str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has__str();
}
inline const ::std::string& ComplexMessage::_str() const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._str)
  return _str_.GetNoArena();
}
inline void ComplexMessage::set__str(const ::std::string& value) {
  set_has__str();
  _str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:test.ComplexMessage._str)
}
#if LANG_CXX11
inline void ComplexMessage::set__str(::std::string&& value) {
  set_has__str();
  _str_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:test.ComplexMessage._str)
}
#endif
inline void ComplexMessage::set__str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has__str();
  _str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:test.ComplexMessage._str)
}
inline void ComplexMessage::set__str(const char* value, size_t size) {
  set_has__str();
  _str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:test.ComplexMessage._str)
}
inline ::std::string* ComplexMessage::mutable__str() {
  set_has__str();
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage._str)
  return _str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComplexMessage::release__str() {
  // @@protoc_insertion_point(field_release:test.ComplexMessage._str)
  clear_has__str();
  return _str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComplexMessage::set_allocated__str(::std::string* _str) {
  if (_str != NULL) {
    set_has__str();
  } else {
    clear_has__str();
  }
  _str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), _str);
  // @@protoc_insertion_point(field_set_allocated:test.ComplexMessage._str)
}

// optional float _float = 2;
inline bool ComplexMessage::has__float() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComplexMessage::set_has__float() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComplexMessage::clear_has__float() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComplexMessage::clear__float() {
  _float_ = 0;
  clear_has__float();
}
inline float ComplexMessage::_float() const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._float)
  return _float_;
}
inline void ComplexMessage::set__float(float value) {
  set_has__float();
  _float_ = value;
  // @@protoc_insertion_point(field_set:test.ComplexMessage._float)
}

// repeated sint64 _int = 3;
inline int ComplexMessage::_int_size() const {
  return _int_.size();
}
inline void ComplexMessage::clear__int() {
  _int_.Clear();
}
inline ::google::protobuf::int64 ComplexMessage::_int(int index) const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._int)
  return _int_.Get(index);
}
inline void ComplexMessage::set__int(int index, ::google::protobuf::int64 value) {
  _int_.Set(index, value);
  // @@protoc_insertion_point(field_set:test.ComplexMessage._int)
}
inline void ComplexMessage::add__int(::google::protobuf::int64 value) {
  _int_.Add(value);
  // @@protoc_insertion_point(field_add:test.ComplexMessage._int)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ComplexMessage::_int() const {
  // @@protoc_insertion_point(field_list:test.ComplexMessage._int)
  return _int_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ComplexMessage::mutable__int() {
  // @@protoc_insertion_point(field_mutable_list:test.ComplexMessage._int)
  return &_int_;
}

// required bytes _bin = 4;
inline bool ComplexMessage::has__bin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComplexMessage::set_has__bin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComplexMessage::clear_has__bin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComplexMessage::clear__bin() {
  _bin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has__bin();
}
inline const ::std::string& ComplexMessage::_bin() const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._bin)
  return _bin_.GetNoArena();
}
inline void ComplexMessage::set__bin(const ::std::string& value) {
  set_has__bin();
  _bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:test.ComplexMessage._bin)
}
#if LANG_CXX11
inline void ComplexMessage::set__bin(::std::string&& value) {
  set_has__bin();
  _bin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:test.ComplexMessage._bin)
}
#endif
inline void ComplexMessage::set__bin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has__bin();
  _bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:test.ComplexMessage._bin)
}
inline void ComplexMessage::set__bin(const void* value, size_t size) {
  set_has__bin();
  _bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:test.ComplexMessage._bin)
}
inline ::std::string* ComplexMessage::mutable__bin() {
  set_has__bin();
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage._bin)
  return _bin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComplexMessage::release__bin() {
  // @@protoc_insertion_point(field_release:test.ComplexMessage._bin)
  clear_has__bin();
  return _bin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComplexMessage::set_allocated__bin(::std::string* _bin) {
  if (_bin != NULL) {
    set_has__bin();
  } else {
    clear_has__bin();
  }
  _bin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), _bin);
  // @@protoc_insertion_point(field_set_allocated:test.ComplexMessage._bin)
}

// required bool _bool = 5;
inline bool ComplexMessage::has__bool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComplexMessage::set_has__bool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComplexMessage::clear_has__bool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComplexMessage::clear__bool() {
  _bool_ = false;
  clear_has__bool();
}
inline bool ComplexMessage::_bool() const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._bool)
  return _bool_;
}
inline void ComplexMessage::set__bool(bool value) {
  set_has__bool();
  _bool_ = value;
  // @@protoc_insertion_point(field_set:test.ComplexMessage._bool)
}

// optional .test.ComplexMessage.SubMessage sub = 10;
inline bool ComplexMessage::has_sub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComplexMessage::set_has_sub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComplexMessage::clear_has_sub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComplexMessage::clear_sub() {
  if (sub_ != NULL) sub_->::test::ComplexMessage_SubMessage::Clear();
  clear_has_sub();
}
inline const ::test::ComplexMessage_SubMessage& ComplexMessage::sub() const {
  const ::test::ComplexMessage_SubMessage* p = sub_;
  // @@protoc_insertion_point(field_get:test.ComplexMessage.sub)
  return p != NULL ? *p : *reinterpret_cast<const ::test::ComplexMessage_SubMessage*>(
      &::test::_ComplexMessage_SubMessage_default_instance_);
}
inline ::test::ComplexMessage_SubMessage* ComplexMessage::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) {
    sub_ = new ::test::ComplexMessage_SubMessage;
  }
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage.sub)
  return sub_;
}
inline ::test::ComplexMessage_SubMessage* ComplexMessage::release_sub() {
  // @@protoc_insertion_point(field_release:test.ComplexMessage.sub)
  clear_has_sub();
  ::test::ComplexMessage_SubMessage* temp = sub_;
  sub_ = NULL;
  return temp;
}
inline void ComplexMessage::set_allocated_sub(::test::ComplexMessage_SubMessage* sub) {
  delete sub_;
  sub_ = sub;
  if (sub) {
    set_has_sub();
  } else {
    clear_has_sub();
  }
  // @@protoc_insertion_point(field_set_allocated:test.ComplexMessage.sub)
}

// repeated .test.ComplexMessage.SubEnum _enum = 11;
inline int ComplexMessage::_enum_size() const {
  return _enum_.size();
}
inline void ComplexMessage::clear__enum() {
  _enum_.Clear();
}
inline ::test::ComplexMessage_SubEnum ComplexMessage::_enum(int index) const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage._enum)
  return static_cast< ::test::ComplexMessage_SubEnum >(_enum_.Get(index));
}
inline void ComplexMessage::set__enum(int index, ::test::ComplexMessage_SubEnum value) {
  assert(::test::ComplexMessage_SubEnum_IsValid(value));
  _enum_.Set(index, value);
  // @@protoc_insertion_point(field_set:test.ComplexMessage._enum)
}
inline void ComplexMessage::add__enum(::test::ComplexMessage_SubEnum value) {
  assert(::test::ComplexMessage_SubEnum_IsValid(value));
  _enum_.Add(value);
  // @@protoc_insertion_point(field_add:test.ComplexMessage._enum)
}
inline const ::google::protobuf::RepeatedField<int>&
ComplexMessage::_enum() const {
  // @@protoc_insertion_point(field_list:test.ComplexMessage._enum)
  return _enum_;
}
inline ::google::protobuf::RepeatedField<int>*
ComplexMessage::mutable__enum() {
  // @@protoc_insertion_point(field_mutable_list:test.ComplexMessage._enum)
  return &_enum_;
}

// repeated string str_list = 12;
inline int ComplexMessage::str_list_size() const {
  return str_list_.size();
}
inline void ComplexMessage::clear_str_list() {
  str_list_.Clear();
}
inline const ::std::string& ComplexMessage::str_list(int index) const {
  // @@protoc_insertion_point(field_get:test.ComplexMessage.str_list)
  return str_list_.Get(index);
}
inline ::std::string* ComplexMessage::mutable_str_list(int index) {
  // @@protoc_insertion_point(field_mutable:test.ComplexMessage.str_list)
  return str_list_.Mutable(index);
}
inline void ComplexMessage::set_str_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:test.ComplexMessage.str_list)
  str_list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ComplexMessage::set_str_list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:test.ComplexMessage.str_list)
  str_list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ComplexMessage::set_str_list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  str_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:test.ComplexMessage.str_list)
}
inline void ComplexMessage::set_str_list(int index, const char* value, size_t size) {
  str_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:test.ComplexMessage.str_list)
}
inline ::std::string* ComplexMessage::add_str_list() {
  // @@protoc_insertion_point(field_add_mutable:test.ComplexMessage.str_list)
  return str_list_.Add();
}
inline void ComplexMessage::add_str_list(const ::std::string& value) {
  str_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:test.ComplexMessage.str_list)
}
#if LANG_CXX11
inline void ComplexMessage::add_str_list(::std::string&& value) {
  str_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:test.ComplexMessage.str_list)
}
#endif
inline void ComplexMessage::add_str_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  str_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:test.ComplexMessage.str_list)
}
inline void ComplexMessage::add_str_list(const char* value, size_t size) {
  str_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:test.ComplexMessage.str_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ComplexMessage::str_list() const {
  // @@protoc_insertion_point(field_list:test.ComplexMessage.str_list)
  return str_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ComplexMessage::mutable_str_list() {
  // @@protoc_insertion_point(field_mutable_list:test.ComplexMessage.str_list)
  return &str_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace test

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::test::ComplexMessage_SubEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::test::ComplexMessage_SubEnum>() {
  return ::test::ComplexMessage_SubEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED
